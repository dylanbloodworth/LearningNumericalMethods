from numpy import ndarray, cos, pi, zeros

def trapezoid(f:'function', n:'int', a:'float', b:'float') -> 'float':
    """
    Integrates a function f with the trapezoid rule. Note that the step size h depends upon the size of interval.

    Parameters
    ----------
    f: function
        the function to be integrated
    n: int
        numbers of boxes used to perform the integration
    a: float
        Lower bound of the integration
    b: float
        Upper bound of the integration
    
    Returns
    -------
    Ans: float
        The desired integral value of the function within the specified region of integration
    """
    # Initialize the widths being used
    h = (b-a)/(n) #notice that n = N-1

    #Adds the boundary terms  to the sums
    sum = (f(a)+f(b))/2

    #Sums the inner terms of the standard from for Trapezoidal rule
    for i in range(1, n):
        sum += f(a+i*h)
    
    #Multiply by the common factor of h (the weight)
    Ans = h*sum

    return Ans

def simpsons(f:'function', n:'int', a:'float', b:'float')->'float':
    """
    Integrates a function f with the trapezoid rule. Note that the step size h depends upon the size of interval

    Also, N must be even!

    Parameters
    ----------
    f: function
        the function to be integrated
    n: int
        numbers of boxes used to perform the integration
    a: float
        Lower bound of the integration
    b: float
        Upper bound of the integration
    
    Returns
    -------
    Ans: float
        The desired integral value of the function within the specified region of integration
    """

    #Check if the number of boxes is even/if the number of intergration points is odd
    if n%2 != 0:
        print("The number of boxes is not even")
        return

    # Initialize the widths being used
    h = (b-a)/(n) #notice that n = N-1

    #Adds the boundary terms to the sums
    sum = f(a)+f(b)

    #Sums the inner terms of the standard form for Simpsons rule
    for i in range(1, n):
        k = a+i*h
        if i%2 == 0: #If i is even
            sum += 2*f(k)
        else:
            sum += 4*f(k)
    
    return (h/3)*sum

def GaussPoints (Npts:'int', a:'float', b:'float', x:'ndarray', w:'ndarray', eps : 'float')->None:
    """
    Generates points and weights for Gaussian quadrature

    Parameters
    ----------
    Npts: int
        Number of points used in the integration. It's associated with the degree of the Legendre polynomial

    a: float
        Lower bound of the integration

    b: float
        Upper bound of the integration

    x: numpy array
        Array of integration points that will be filled with the roots of the N-order Legendre polynomial
    
    w: numpy array
        Array of integration points that will be filled with the weights found using the derivative formula of the Legendre polynomial

    eps: float
        The precision to use when calculating the points

    Returns
    -------
    None
    """

    m = 0 ; i = 0 ; j = 0 ; t = 0 ; t1 = 0; pp = 0
    p1 = 0 ; p2 = 0 ; p3 = 0
    m = int ((Npts+1)/2)


    for i in range (1, m+1):
        t = cos(pi*(float(i)-0.25)/(float(Npts)+0.5))
        t1 = 1

        while((abs(t-t1)) >= eps):
            p1 = 1 ; p2 = 0
            
            for j in range(1, Npts + 1):
                p3 = p2 ; p2 = p1
                p1 = ((2*float(j)-1)*t*p2 - (float(j)-1)*p3)/(float(j))
                      
            pp = Npts*(t*p1-p2)/(t*t-1)
            t1 = t
            t = t1-p1/pp

        x [i-1] = -t
        x [Npts-i] = t
        w [i-1] = 2/((1-t*t)*pp*pp)
        w [Npts-i] = w [i-1]
                          
    for j in range(0, Npts) : #Scale [-1,1] to [a,b]
        x[j] = x[j]*(b-a)/2 + (b+a)/2
        w[j] = w[j]*(b-a)/2


def gaussQuad(f:'function', N:'int', a:'float', b:'float', eps:'float')->'float':
    """
    Gaussian quadrature using points and weights generated by GaussPoints with precision eps

    Parameters
    ----------
    f: function
        The function to be integrated
    N: int
        Number of integration points
    a: float
        Lower bound of the integration
    b: float
        Upper bound of the integration
    eps: float
        The precision of the Gaussian Quadrature calculation

    Returns
    --------
    Ans: float
        The desired integral value of the function within the specified region of integration
    """

    x = zeros(N) ; w = zeros(N) #Initalizes the arrays for the integration points and the weights

    GaussPoints(N, a, b, x, w, eps) #Calls the GaussPoint func to populate the arrays with the needs integration points and weights

    Ans = 0
    for i in range(0,N):
        Ans += f(x[i])*w[i] #Sums all the function values and weights from the standard from

    return Ans